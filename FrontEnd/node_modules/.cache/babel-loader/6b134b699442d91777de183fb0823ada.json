{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\nconst {\n  Events\n} = require(`./events`);\n\nconst {\n  ColorConsole\n} = require(`./utils/color`);\n\nconst npm = {\n  utils: require(`./utils`),\n  text: require(`./text`),\n  formatting: require(`./formatting`)\n};\n\nfunction poolConnect(ctx, db, config) {\n  return config.promise((resolve, reject) => {\n    const p = db.$pool;\n\n    if (p.ending) {\n      db.$destroy();\n      const err = new Error(npm.text.poolDestroyed);\n      Events.error(ctx.options, err, {\n        dc: ctx.dc\n      });\n      reject(err);\n      return;\n    }\n\n    p.connect((err, client) => {\n      if (err) {\n        Events.error(ctx.options, err, {\n          cn: npm.utils.getSafeConnection(ctx.cn),\n          dc: ctx.dc\n        });\n        reject(err);\n      } else {\n        if (`$useCount` in client) {\n          // Make sure useCount drops to 1, if it ever reaches maximum integer number;\n          // We do not drop it to zero, to avoid rerun of initialization queries that\n          // usually check for useCount === 0;\n          client.$useCount = client.$useCount >= Number.MAX_SAFE_INTEGER ? 1 : ++client.$useCount;\n        } else {\n          Object.defineProperty(client, `$useCount`, {\n            value: 0,\n            configurable: false,\n            enumerable: false,\n            writable: true\n          });\n          setSchema(client, ctx);\n        }\n\n        setCtx(client, ctx);\n        const end = lockClientEnd(client);\n        client.on(`error`, onError);\n        resolve({\n          client,\n          useCount: client.$useCount,\n\n          release(kill) {\n            client.end = end;\n            client.release(kill || client.$connectionError);\n            Events.disconnect(ctx, client);\n            client.removeListener(`error`, onError);\n          }\n\n        });\n        Events.connect(ctx, client, client.$useCount);\n      }\n    });\n  });\n}\n\nfunction directConnect(ctx, config) {\n  return config.promise((resolve, reject) => {\n    const client = new config.pgp.pg.Client(ctx.cn);\n    client.connect(err => {\n      if (err) {\n        Events.error(ctx.options, err, {\n          cn: npm.utils.getSafeConnection(ctx.cn),\n          dc: ctx.dc\n        });\n        reject(err);\n      } else {\n        setSchema(client, ctx);\n        setCtx(client, ctx);\n        const end = lockClientEnd(client);\n        client.on(`error`, onError);\n        resolve({\n          client,\n          useCount: 0,\n\n          release() {\n            client.end = end;\n            const p = config.promise((res, rej) => client.end().then(res).catch(rej));\n            Events.disconnect(ctx, client);\n            client.removeListener(`error`, onError);\n            return p;\n          }\n\n        });\n        Events.connect(ctx, client, 0);\n      }\n    });\n  });\n} // this event only happens when the connection is lost physically,\n// which cannot be tested automatically; removing from coverage:\n// istanbul ignore next\n\n\nfunction onError(err) {\n  const ctx = this.$ctx;\n  const cn = npm.utils.getSafeConnection(ctx.cn);\n  Events.error(ctx.options, err, {\n    cn,\n    dc: ctx.dc\n  });\n\n  if (ctx.cnOptions && typeof ctx.cnOptions.onLost === `function` && !ctx.notified) {\n    try {\n      ctx.cnOptions.onLost.call(this, err, {\n        cn,\n        dc: ctx.dc,\n        start: ctx.start,\n        client: this\n      });\n    } catch (e) {\n      ColorConsole.error(e && e.stack || e);\n    }\n\n    ctx.notified = true;\n  }\n}\n\nfunction lockClientEnd(client) {\n  const end = client.end;\n\n  client.end = doNotCall => {\n    // This call can happen only in the following two cases:\n    // 1. the client made the call directly, against the library's documentation (invalid code)\n    // 2. connection with the server broke, and the pool is terminating all clients forcefully.\n    ColorConsole.error(`${npm.text.clientEnd}\\n${npm.utils.getLocalStack(1, 3)}\\n`);\n\n    if (!doNotCall) {\n      end.call(client);\n    }\n  };\n\n  return end;\n}\n\nfunction setCtx(client, ctx) {\n  Object.defineProperty(client, `$ctx`, {\n    value: ctx,\n    writable: true\n  });\n}\n\nfunction setSchema(client, ctx) {\n  let s = ctx.options.schema;\n\n  if (!s) {\n    return;\n  }\n\n  if (typeof s === `function`) {\n    s = s.call(ctx.dc, ctx.dc);\n  }\n\n  if (Array.isArray(s)) {\n    s = s.filter(a => a && typeof a === `string`);\n  }\n\n  if (typeof s === `string` || Array.isArray(s) && s.length) {\n    client.query(npm.formatting.as.format(`SET search_path TO $1:name`, [s]), err => {\n      // istanbul ignore if;\n      if (err) {\n        // This is unlikely to ever happen, unless the connection is created faulty,\n        // and fails on the very first query, which is impossible to test automatically.\n        throw err;\n      }\n    });\n  }\n}\n\nmodule.exports = config => ({\n  pool: (ctx, db) => poolConnect(ctx, db, config),\n  direct: ctx => directConnect(ctx, config)\n});","map":{"version":3,"sources":["C:/Users/Vinson Chen/Desktop/DisclosedWebsite/node_modules/pg-promise/lib/connect.js"],"names":["Events","require","ColorConsole","npm","utils","text","formatting","poolConnect","ctx","db","config","promise","resolve","reject","p","$pool","ending","$destroy","err","Error","poolDestroyed","error","options","dc","connect","client","cn","getSafeConnection","$useCount","Number","MAX_SAFE_INTEGER","Object","defineProperty","value","configurable","enumerable","writable","setSchema","setCtx","end","lockClientEnd","on","onError","useCount","release","kill","$connectionError","disconnect","removeListener","directConnect","pgp","pg","Client","res","rej","then","catch","$ctx","cnOptions","onLost","notified","call","start","e","stack","doNotCall","clientEnd","getLocalStack","s","schema","Array","isArray","filter","a","length","query","as","format","module","exports","pool","direct"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {Events} = require(`./events`);\r\nconst {ColorConsole} = require(`./utils/color`);\r\n\r\nconst npm = {\r\n    utils: require(`./utils`),\r\n    text: require(`./text`),\r\n    formatting: require(`./formatting`)\r\n};\r\n\r\nfunction poolConnect(ctx, db, config) {\r\n    return config.promise((resolve, reject) => {\r\n        const p = db.$pool;\r\n        if (p.ending) {\r\n            db.$destroy();\r\n            const err = new Error(npm.text.poolDestroyed);\r\n            Events.error(ctx.options, err, {\r\n                dc: ctx.dc\r\n            });\r\n            reject(err);\r\n            return;\r\n        }\r\n        p.connect((err, client) => {\r\n            if (err) {\r\n                Events.error(ctx.options, err, {\r\n                    cn: npm.utils.getSafeConnection(ctx.cn),\r\n                    dc: ctx.dc\r\n                });\r\n                reject(err);\r\n            } else {\r\n                if (`$useCount` in client) {\r\n                    // Make sure useCount drops to 1, if it ever reaches maximum integer number;\r\n                    // We do not drop it to zero, to avoid rerun of initialization queries that\r\n                    // usually check for useCount === 0;\r\n                    client.$useCount = client.$useCount >= Number.MAX_SAFE_INTEGER ? 1 : ++client.$useCount;\r\n                } else {\r\n                    Object.defineProperty(client, `$useCount`, {\r\n                        value: 0,\r\n                        configurable: false,\r\n                        enumerable: false,\r\n                        writable: true\r\n                    });\r\n                    setSchema(client, ctx);\r\n                }\r\n                setCtx(client, ctx);\r\n                const end = lockClientEnd(client);\r\n                client.on(`error`, onError);\r\n                resolve({\r\n                    client,\r\n                    useCount: client.$useCount,\r\n                    release(kill) {\r\n                        client.end = end;\r\n                        client.release(kill || client.$connectionError);\r\n                        Events.disconnect(ctx, client);\r\n                        client.removeListener(`error`, onError);\r\n                    }\r\n                });\r\n                Events.connect(ctx, client, client.$useCount);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nfunction directConnect(ctx, config) {\r\n    return config.promise((resolve, reject) => {\r\n        const client = new config.pgp.pg.Client(ctx.cn);\r\n        client.connect(err => {\r\n            if (err) {\r\n                Events.error(ctx.options, err, {\r\n                    cn: npm.utils.getSafeConnection(ctx.cn),\r\n                    dc: ctx.dc\r\n                });\r\n                reject(err);\r\n            } else {\r\n                setSchema(client, ctx);\r\n                setCtx(client, ctx);\r\n                const end = lockClientEnd(client);\r\n                client.on(`error`, onError);\r\n                resolve({\r\n                    client,\r\n                    useCount: 0,\r\n                    release() {\r\n                        client.end = end;\r\n                        const p = config.promise((res, rej) => client.end().then(res).catch(rej));\r\n                        Events.disconnect(ctx, client);\r\n                        client.removeListener(`error`, onError);\r\n                        return p;\r\n                    }\r\n                });\r\n                Events.connect(ctx, client, 0);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n// this event only happens when the connection is lost physically,\r\n// which cannot be tested automatically; removing from coverage:\r\n// istanbul ignore next\r\nfunction onError(err) {\r\n    const ctx = this.$ctx;\r\n    const cn = npm.utils.getSafeConnection(ctx.cn);\r\n    Events.error(ctx.options, err, {cn, dc: ctx.dc});\r\n    if (ctx.cnOptions && typeof ctx.cnOptions.onLost === `function` && !ctx.notified) {\r\n        try {\r\n            ctx.cnOptions.onLost.call(this, err, {\r\n                cn,\r\n                dc: ctx.dc,\r\n                start: ctx.start,\r\n                client: this\r\n            });\r\n        } catch (e) {\r\n            ColorConsole.error(e && e.stack || e);\r\n        }\r\n        ctx.notified = true;\r\n    }\r\n}\r\n\r\nfunction lockClientEnd(client) {\r\n    const end = client.end;\r\n    client.end = doNotCall => {\r\n        // This call can happen only in the following two cases:\r\n        // 1. the client made the call directly, against the library's documentation (invalid code)\r\n        // 2. connection with the server broke, and the pool is terminating all clients forcefully.\r\n        ColorConsole.error(`${npm.text.clientEnd}\\n${npm.utils.getLocalStack(1, 3)}\\n`);\r\n        if (!doNotCall) {\r\n            end.call(client);\r\n        }\r\n    };\r\n    return end;\r\n}\r\n\r\nfunction setCtx(client, ctx) {\r\n    Object.defineProperty(client, `$ctx`, {\r\n        value: ctx,\r\n        writable: true\r\n    });\r\n}\r\n\r\nfunction setSchema(client, ctx) {\r\n    let s = ctx.options.schema;\r\n    if (!s) {\r\n        return;\r\n    }\r\n    if (typeof s === `function`) {\r\n        s = s.call(ctx.dc, ctx.dc);\r\n    }\r\n    if (Array.isArray(s)) {\r\n        s = s.filter(a => a && typeof a === `string`);\r\n    }\r\n    if (typeof s === `string` || (Array.isArray(s) && s.length)) {\r\n        client.query(npm.formatting.as.format(`SET search_path TO $1:name`, [s]), err => {\r\n            // istanbul ignore if;\r\n            if (err) {\r\n                // This is unlikely to ever happen, unless the connection is created faulty,\r\n                // and fails on the very first query, which is impossible to test automatically.\r\n                throw err;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nmodule.exports = config => ({\r\n    pool: (ctx, db) => poolConnect(ctx, db, config),\r\n    direct: ctx => directConnect(ctx, config)\r\n});\r\n"]},"metadata":{},"sourceType":"script"}